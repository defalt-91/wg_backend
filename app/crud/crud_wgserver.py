import logging
import os
import pathlib
from datetime import datetime
from typing import Type

import pyroute2
from sqlalchemy.orm import Session

from app.api import exceptions
from app.core.Settings import get_settings
from app.crud.base import CRUDBase
from app.models.peer import Peer
from app.models.wg_interface import WGInterface
from app.schemas.wg_interface import WGInterfaceCreate, WGInterfaceUpdate, WGInterfaceConfig, WGInterfacePeer

settings = get_settings()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class CRUDWGInterface(CRUDBase[WGInterface, WGInterfaceCreate, WGInterfaceUpdate]):
    def __init__(self, model: Type[WGInterface]):
        self.wg = pyroute2.WireGuard()
        super().__init__(model)

    def get_one(self, session: Session) -> Type[WGInterface]:
        return session.query(self.model).one()

    def get_server_config(self, session: Session) -> Type[WGInterface] | None:
        return session.query(self.model).first()

    def create_wg_quick_config_file(self, orm_server: WGInterface):
        logger.info(
            f"Writing database server config file to: {pathlib.Path(settings.wgserver_file_path).resolve()}"
        )
        result = []
        result.append("# Note: Do not edit this file directly.")
        result.append(f"# Your changes will be overwritten!{os.linesep}# Server")
        result.append(f"{os.linesep}[Interface]")
        result.append(f"PrivateKey = {orm_server.private_key}")
        result.append(f"Address = {orm_server.address}/24")
        result.append(f"ListenPort = {settings.WG_HOST_PORT}")
        if settings.WG_MTU:
            result.append(f"MTU = {settings.WG_MTU}")
        result.append(f"PreUp = {settings.WG_PRE_UP}")
        result.append(f"PostUp = {settings.WG_POST_UP}")
        result.append(f"PreDown = {settings.WG_PRE_DOWN}")
        result.append(f"PostDown = {settings.WG_POST_DOWN}")
        result.append(f"SaveConfig = true")
        logger.debug("Server Config saving...")
        with open(file=settings.wgserver_file_path, mode="w+", encoding="utf-8") as f:
            f.write(os.linesep.join(result))
        logger.debug(f"Server Config saved to -->{settings.wgserver_file_path}")
        return result

    def sync_db_peers_to_wg(self, db: Session):
        logger.info("Peers loading from database ...")
        peers = db.query(Peer).all()
        if len(peers):
            for peer in peers:
                self.add_peer(peer)
        logger.debug("Peers synced to wg service.")

    def add_peer(self, peer: Peer | Type[Peer]):
        logger.debug("adding new peer to wg", peer.id)
        new_peer = self.set_peer_args(peer=peer)
        try:
            self.wg.set(
                interface=settings.WG_INTERFACE,
                listen_port=settings.WG_HOST_PORT,
                fwmark=None,
                # private_key=server.privateKey,
                peer=new_peer.model_dump(
                    exclude_none=True,
                    exclude_unset=True,
                    exclude={"endpoint_addr", "endpoint_port"},
                ),
            )
        except pyroute2.NetlinkError as err:
            logger.error("Error when adding app peer to wg interface", err)
            raise exceptions.wg_add_peer_error()

    def remove_peer(self, public_key: str):
        try:
            self.wg.set(
                settings.WG_INTERFACE, peer={"public_key": str(public_key), "remove": True}
            )
        except pyroute2.NetlinkError as err:
            logger.error("Error when removing app peer to wg interface", err)
            raise exceptions.wg_remove_peer_error()

    def update_peer(self, peer: Peer):
        updated_peer = self.set_peer_args(peer=peer)
        updated_peer_dict = updated_peer.model_dump(
            exclude_none=True,
            exclude_unset=True,
            exclude={"endpoint_addr", "endpoint_port"},
        )
        try:
            self.wg.set(
                interface=settings.WG_INTERFACE,
                peer=updated_peer_dict,
            )
        except pyroute2.NetlinkError as err:
            logger.error("Error when updating peer to wg interface", err)
            raise exceptions.wg_update_peer_error()


    def set_peer_args(self, peer: Peer):
        return WGInterfacePeer(
            public_key=peer.public_key,
            endpoint_addr=str(settings.WG_HOST_IP),
            endpoint_port=settings.WG_HOST_PORT,
            preshared_key=peer.preshared_key,
            persistent_keepalive=peer.persistent_keepalive,
            address=f"{peer.address}/32",
        )

    def get_rxtx_config(self) -> list[WGInterfacePeer]:
        try:
            if_peers = dict(self.wg.info(settings.WG_INTERFACE)[0]["attrs"])
            if_peers = if_peers.get("WGDEVICE_A_PEERS", {})
            # with open(f"{settings.WG_CONFIG_DIR_PATH}/wg_output_attrs.py", "w+") as f:
            #     f.write(attrs.__str__())
        except pyroute2.netlink.exceptions.NetlinkError as exc:
            msg = f"Unable to access interface: {exc.args[1]}"
            raise exceptions.wg_dump_error(msg)
        return [
            WGInterfacePeer(
                public_key=peer.get("WGPEER_A_PUBLIC_KEY").decode("utf-8"),
                preshared_key=peer.get("WGPEER_A_PRESHARED_KEY").decode("utf-8"),
                last_handshake_at=peer.get("WGPEER_A_LAST_HANDSHAKE_TIME", {}).get("tv_sec"),
                tx_bytes=peer.get("WGPEER_A_TX_BYTES", 0),
                rx_bytes=peer.get("WGPEER_A_RX_BYTES", 0),
            ) for peer in if_peers]

    def get_full_config(self, db: Session) -> list[Type[Peer]]:
        peers = db.query(Peer).all()
        try:
            if_peers = dict(self.wg.info(settings.WG_INTERFACE)[0]["attrs"])
            if_peers = if_peers.get("WGDEVICE_A_PEERS", {})
            # if_peers = if_peers.get("attrs", {})
            # with open(f"{settings.WG_CONFIG_DIR_PATH}/wg_output_attrs.py", "w+") as f:
            #     f.write(attrs.__str__())
        except pyroute2.netlink.exceptions.NetlinkError as exc:
            msg = f"Unable to access interface: {exc.args[1]}"
            raise exceptions.wg_dump_error(exc)
        for db_peer in peers:
            for peer in if_peers:
                if db_peer.public_key==peer.get("WGPEER_A_PUBLIC_KEY").decode("utf-8"):
                    db_peer.transfer_tx = peer.get("WGPEER_A_TX_BYTES", 0)
                    db_peer.transfer_rx = peer.get("WGPEER_A_RX_BYTES", 0)
                    lha = peer.get("WGPEER_A_LAST_HANDSHAKE_TIME", {}).get("tv_sec")
                    if lha and type(lha) == str:
                        db_peer.last_handshake_at = datetime.fromisoformat(lha)
                    elif lha and type(lha) == int:
                        db_peer.last_handshake_at = datetime.fromtimestamp(lha)
                    db_peer.endpoint_addr=f"""{peer.get("WGPEER_A_ENDPOINT", {}).get("addr", None)}"""
                    f"""{peer.get("WGPEER_A_ENDPOINT", {}).get("port", None)}"""
        db.add_all(peers)
        return peers


crud_wg_interface = CRUDWGInterface(WGInterface)
