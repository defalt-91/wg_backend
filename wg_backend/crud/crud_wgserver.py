import json
import logging
import os
from typing import Type

from sqlalchemy import select
from sqlalchemy.orm import Session

from wg_backend.api import exceptions
from wg_backend.core.configs.Settings import get_settings
from wg_backend.core.configs.Settings import execute
from wg_backend.crud.base import CRUDBase
from wg_backend.models.peer import Peer
from wg_backend.models.wg_interface import WGInterface
from wg_backend.schemas.Peer import DBPlusStdoutPeer, DbDataPeer, StdoutDumpPeer, StdoutRxTxPlusLhaPeer
from wg_backend.schemas.wg_interface import WGInterfaceCreate
from wg_backend.schemas.wg_interface import WGInterfaceUpdate

settings = get_settings()
logging.basicConfig(level = settings.LOG_LEVEL)
logger = logging.getLogger(__name__)


class CRUDWGInterface(CRUDBase[WGInterface, WGInterfaceCreate, WGInterfaceUpdate]):
    def get_one(self, session: Session) -> Type[WGInterface]:
        return session.query(self.model).one()

    def get_if_db(self, session: Session, interface_id: int) -> Type[WGInterface] | None:
        return session.query(self.model).get(ident = interface_id)

    def get_if_private_key(self, session: Session, interface_id: int) -> Type[WGInterface] | None:
        return session.query(self.model).get(ident = interface_id)

    @classmethod
    def create_wg_quick_config_file(cls, session: Session, interface_id: int) -> Type[WGInterface]:
        logger.info(f"Writing database server config file to: {settings.wg_if_config_file_path}")
        orm_interface = session.get(WGInterface, interface_id)
        result = []
        result.append("# Note: Do not edit this file directly.")
        result.append(f"# Your changes will be overwritten!{os.linesep}# Server")
        result.append(f"{os.linesep}[Interface]")
        result.append(f"PrivateKey = {orm_interface.private_key}")
        result.append(f"Address = {settings.WG_SUBNET}")
        result.append(f"ListenPort = {settings.WG_HOST_PORT}")
        if settings.WG_MTU:
            result.append(f"MTU = {settings.WG_MTU}")
        result.append(f"PreUp = {settings.WG_PRE_UP}")
        result.append(f"PostUp = {settings.WG_POST_UP}")
        result.append(f"PreDown = {settings.WG_PRE_DOWN}")
        result.append(f"PostDown = {settings.WG_POST_DOWN}")
        # result.append(f"SaveConfig = true")
        logger.debug("Server Config saving...")
        peers = orm_interface.peers
        peers_conf = cls.create_peers_config_file(peers)
        with open(file = settings.wg_if_config_file_path, mode = "w", encoding = "utf-8") as f:
            f.write(os.linesep.join(result))
        logger.debug(f"Server Config saved to -->{settings.wg_if_config_file_path}")

    @staticmethod
    def create_peers_config_file(clients: list[Type[Peer]]) -> list[str]:
        logger.debug(f"Writing peers config file to: {settings.wg_if_peers_config_file_path}")
        logger.debug("Peers loading from database ...")
        conf = []
        for client in clients:
            if not client.enabled:
                continue
            conf.append(f"{os.linesep}[Peer]")
            if client.friendly_name:
                conf.append(f"# friendly_name = {client.friendly_name}")
            if client.friendly_json is not None:
                value = json.dumps(client.friendly_json)
                conf.append(f"# friendly_json = {value}")
            conf.append(f"# Client: {client.name} ({client.id})")
            conf.append(f"PublicKey = {client.public_key}")
            if client.preshared_key:
                conf.append(f"PresharedKey = {client.preshared_key}")
            # if client.endpoint_host:
            #     conf.append(f"Endpoint = {settings.WG_HOST}:{settings.WG_PORT}")
            if client.persistent_keepalive:
                conf.append(f"PersistentKeepalive = {client.persistent_keepalive}")
            conf.append(f"AllowedIPs = {client.address}/32")
        with open(file = settings.wg_if_peers_config_file_path, mode = "w", encoding = "utf-8") as f:
            f.write(os.linesep.join(conf))
        logger.debug("Peers synced to wg interface.")
        return conf

    @classmethod
    def sync_peers_config_file_to_interface(cls, peers: list[Type[Peer]]) -> None:
        # logger.debug("adding new peer to wg", peer.id)
        config = cls.create_peers_config_file(clients = peers)
        cmd = ["sudo", "wg", "addconf", settings.WG_INTERFACE_NAME, settings.wg_if_peers_config_file_path]
        res = execute(cmd)
        if res.stderr:
            raise exceptions.server_error()

    def remove_peer_from_if(self, peer: Peer) -> None:
        cmd = ["sudo", 'wg', 'set', settings.WG_INTERFACE_NAME, "peer", peer.public_key, "remove"]
        return execute(cmd)

    @staticmethod
    def get_rxtx_lha_config() -> list[StdoutRxTxPlusLhaPeer]:
        peers_rxtx_lha: list[StdoutRxTxPlusLhaPeer] = []
        cmd = ["sudo", "wg", "show", settings.WG_INTERFACE_NAME, "transfer"]
        cmd2 = ["sudo", "wg", "show", settings.WG_INTERFACE_NAME, "latest-handshakes"]
        transfer_proc = execute(cmd)
        lha_proc = execute(cmd2)
        if transfer_proc.stderr or lha_proc.stderr:
            raise exceptions.wg_dump_error(transfer_proc.stderr)
        if transfer_proc.stdout and lha_proc.stdout:
            rxtx_list: list[str] = transfer_proc.stdout.strip().split(os.linesep)
            lha_list: list[str] = lha_proc.stdout.strip().split(os.linesep)
            peers_rxtx_lha = [
                StdoutRxTxPlusLhaPeer.from_rxtx_lha_stdout(
                    rx_rt_str = rxtx_str,
                    lha_str = lha_str
                ) for rxtx_str, lha_str in zip(rxtx_list, lha_list)
            ]
        return peers_rxtx_lha

    @staticmethod
    def get_full_config(session: Session)-> dict[str, DBPlusStdoutPeer]:
        full_config: dict[str, DBPlusStdoutPeer] = dict()
        cmd = ["sudo", "wg", "show", settings.WG_INTERFACE_NAME, "dump"]
        proc = execute(cmd)
        stmt = select(Peer.id, Peer.public_key, Peer.name, Peer.enabled, Peer.created_at, Peer.updated_at)
        peers_data = session.execute(stmt).fetchall()
        if proc.stderr:
            raise exceptions.server_error()
        dump_peers_str_list = proc.stdout.strip()
        skipped_interface_str = dump_peers_str_list.split(os.linesep)[1::]
        """ loading db data """
        peers_db_data = [DbDataPeer.from_orm(db_data) for db_data in peers_data]
        """ loading dump data """
        peers_dump_data = [StdoutDumpPeer.from_dump_stdout(db_data) for db_data in skipped_interface_str]
        for db_peer in peers_db_data:
            """" adding db data """
            full_config[db_peer.public_key] = DBPlusStdoutPeer(**db_peer.model_dump(exclude_none = True))
            for dump_peer in peers_dump_data:
                if db_peer.public_key == dump_peer.public_key:
                    """" adding dump data """
                    full_config[db_peer.public_key].last_handshake_at = dump_peer.last_handshake_at,
                    full_config[db_peer.public_key].transfer_rx = dump_peer.transfer_rx,
                    full_config[db_peer.public_key].transfer_tx = dump_peer.transfer_tx,
                    full_config[db_peer.public_key].persistent_keepalive = dump_peer.persistent_keepalive
                    break
        return full_config


crud_wg_interface = CRUDWGInterface(WGInterface)
